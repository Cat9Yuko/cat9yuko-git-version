<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>事件处理</title>
</head>
<body>
    <div id="app">
        <h1>事件处理</h1>
        <h4>#监听事件</h4>
        <p>可以用 v-on 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。</p>
        <p><button v-on:click="counter += 1">Add 1</button></p>
        <p>{{counter}}</p>
        <h4>#事件处理方法</h4>
        <p>然而许多事件处理逻辑会更为复杂，所以直接把 JavaScript 代码写在 v-on 指令中是不可行的。因此 v-on 还可以接收一个需要调用的方法名称。</p>
        <p><button v-on:click="greet">Greet</button></p>
        <h4>#内联处理器中的方法</h4>
        <p>除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法</p>
        <p><button v-on:click="say('hi')">Say hi</button></p>
        <p><button v-on:click="say('what')">Say what</button></p>
        <p>有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法：</p>
        <p><button v-on:click="warn('Form cannot be submitted yet.',$event)">Submit</button></p>
        <h4>#事件修饰符</h4>
        <p>在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</p>
        <p>为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符。之前提过，修饰符是由点开头的指令后缀来表示的。</p>
        <ul>
            <li>.stop</li>
            <li>.prevent</li>
            <li>.capture</li>
            <li>.self</li>
            <li>.once</li>
            <li>.passive</li>
        </ul>
        <a v-on:click.stop="doThis">阻止单击事件继续传播</a>
        <form v-on:submit.prevent="onSubmit"><button>提交事件不再重载页面</button></form>
        <a v-on:click.stop.prevent="doThis">修饰符可以串联</a>
        <form v-on:submit.prevent="onSubmit"><button>只有修饰符</button></form>
        <!-- 添加事件监听器时使用事件捕获模式 -->
        <!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->
        <div v-on:click.capture="doThis">添加事件监听器时使用事件捕获模式</div>
        <!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
        <!-- 即事件不是从内部元素触发的 -->
        <p v-on:click.self="doThis">只当在 event.target 是当前元素自身时触发处理函数</p>
        <p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。</p>
        <!-- 点击事件将只会触发一次 -->
        <p v-on:click.onece="doThis">点击事件将只会触发一次</p>
        <!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 -->
        <!-- 而不会等待 `onScroll` 完成  -->
        <!-- 这其中包含 `event.preventDefault()` 的情况 -->
        <div v-on:scroll.passive="onScroll">滚动事件的默认行为 (即滚动行为) 将会立即触发</div>
        <p>这个 .passive 修饰符尤其能够提升移动端的性能。</p>
        <div v-on:click.passive="doThis">不要把 .passive 和 .prevent 一起使用，因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，.passive 会告诉浏览器你不想阻止事件的默认行为。</div>
        <h4>#按键修饰符</h4>
        
    </div>
    <script src="vue.js"></script>
    <script>
        var vm = new Vue({
            el: '#app',
            data: {
                message: 'message',
                counter: 0,
                name: 'Vue.js'
            },
            methods: {
                greet: function(event){
                    // `this` 在方法里指向当前 Vue 实例
                    alert('Hello' + this.name + '!')
                    // `event` 是原生 DOM 事件
                    if(event) {
                        alert(event.target.tagName)
                    }
                },
                say: function(message){
                    alert(message)
                },
                warn: function(message, event){
                    // 现在我们可以访问原生事件对象
                    if(event) {
                        event.preventDefault()
                    }
                    alert(message)
                },
                onSubmit: function(){},
                doThis: function(){},
                onScroll: function(){}
            },
        })

        // vm.greet()
    </script>
</body>
</html>