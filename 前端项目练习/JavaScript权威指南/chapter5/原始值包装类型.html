<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>原始值包装类型</title>
</head>
<body>
    <script>
        /* 为了方便操作原始值， ECMAScript 提供了 3 种特殊的引用类型： Boolean、 Number 和 String。
这些类型具有本章介绍的其他引用类型一样的特点，但也具有与各自原始类型对应的特殊行为。每当用
到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的
各种方法。 */
        // let s1 = "some text";
        // let s2 = s1.substring(2);
        // console.log(s2);

        /* 当
第二行访问 s1 时，是以读模式访问的，也就是要从内存中读取变量保存的值。在以读模式访问字符串
值的任何时候，后台都会执行以下 3 步：
        (1) 创建一个 String 类型的实例；
        (2) 调用实例上的特定方法；
        (3) 销毁实例。
        */
    //    let s1 = new String("some text");
    //    let s2 = s1.substring(2);
    //    s1 = null;

        /* 引用类型与原始值包装类型的主要区别在于对象的生命周期。在通过 new 实例化引用类型后，得到
的实例会在离开作用域时被销毁，而自动创建的原始值包装对象则只存在于访问它的那行代码执行期
间。这意味着不能在运行时给原始值添加属性和方法。 */

        // let s1 = "some text";
        // s1.color = "red";
        // console.log(s1.color); // undefined

        // let obj = new Object("some text");
        // console.log(obj instanceof String);

//         如果传给 Object 的是字符串，则会创建一个 String 的实例。如果是数值，则会创建 Number 的
// 实例。布尔值则会得到 Boolean 的实例。

        // 注意，使用 new 调用原始值包装类型的构造函数，与调用同名的转型函数并不一样。例如：

        // let value = "25"
        // let number = Number(value) // 转型函数
        // console.log(typeof number);

        // let obj = new Number(value) // 构造函数
        // console.log(typeof obj);

        // Boolean
        /* Boolean 是对应布尔值的引用类型。要创建一个 Boolean 对象，就使用 Boolean 构造函数并传入
true 或 false，如下例所示： */
        let booleanObject = new Boolean(true);
        /* Boolean 的实例会重写 valueOf()方法，返回一个原始值 true 或 false。 toString()方法被调
用时也会被覆盖，返回字符串"true"或"false"。 */
        let falseObject = new Boolean(false);
        let result = falseObject && true;
        // console.log(result);

        let falseValue = false;
        result = falseValue && true;
        // console.log(result);
        /* 除此之外，原始值和引用值（ Boolean 对象）还有几个区别。首先， typeof 操作符对原始值返回
"boolean"，但对引用值返回"object"。同样， Boolean 对象是 Boolean 类型的实例，在使用
instaceof 操作符时返回 true，但对原始值则返回 false，如下所示： */
        // console.log(typeof falseObject);
        // console.log(typeof falseValue);
        // console.log(falseObject instanceof Boolean);
        // console.log(falseValue instanceof Boolean);

        // Number
        /* Number 是对应数值的引用类型。要创建一个 Number 对象，就使用 Number 构造函数并传入一个
数值，如下例所示： */
        let numberObject = new Number(10)
        /* 与 Boolean 类型一样， Number 类型重写了 valueOf()、 toLocaleString()和 toString()方
法。 valueOf()方法返回 Number 对象表示的原始数值，另外两个方法返回数值字符串。 */
        // console.log(numberObject.valueOf());
        // console.log(numberObject.toLocaleString());
        // toString() 方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串，如下所示：
        // let num = 10
        // console.log(num.toString());
        // console.log(num.toString(2));
        // console.log(num.toString(8));
        // console.log(num.toString(10));
        // console.log(num.toString(16));

        /* 除了继承的方法， Number 类型还提供了几个用于将数值格式化为字符串的方法。
toFixed()方法返回包含指定小数点位数的数值字符串，如： */

        let num = 10
        // console.log(num.toFixed(2));
        // 如果数值本身的小数位超过了参数指定的位数，则四舍五入到最接近的116 第 5 章 基本引用类型小数位
        let num2 = 10.005
        // console.log(num2.toFixed(2));
        /* 注意 toFixed()方法可以表示有 0~20 个小数位的数值。某些浏览器可能支持更大的范
围，但这是通常被支持的范围。 */

        let num3 = 10;
        // console.log(num3.toExponential(1));
        // 一般来说，这么小的数不用表示为科学记数法形式。如果想得到数值最适当的形式，那么可以使用 toPrecision()。
        // console.log(num3.toPrecision());
        // 这个方法接收一个参数，表示结果中数字的总位数（不包含指数）。
        let num4 = 99;
        // console.log(num4.toPrecision(1));
        // console.log(num4.toPrecision(2));
        // console.log(num4.toPrecision(3));
        /* 注意 toPrecision()方法可以表示带 1~21 个小数位的数值。某些浏览器可能支持更大
的范围，但这是通常被支持的范围。 */
        let numberValue = 10
        // console.log(typeof numberObject);
        // console.log(typeof numberValue);
        // console.log(numberObject instanceof Number);
        // console.log(numberValue instanceof Number);

        // isInteger()方法和安全整数
        /* ES6 新增了 Number.isInteger()方法，用于辨别一个数值是否保存为整数。有时候，小数位的 0
可能会让人误以为数值是一个浮点值： */
        // console.log(Number.isInteger(1));
        // console.log(Number.isInteger(1.00));
        // console.log(Number.isInteger(1.01));
        /* IEEE 754 数值格式有一个特殊的数值范围，在这个范围内二进制值可以表示一个整数值。这个数值
范围从 Number.MIN_SAFE_INTEGER（ -2^53 + 1）到 Number.MAX_SAFE_INTEGER（ 2^53 - 1）。对超出这
个范围的数值，即使尝试保存为整数， IEEE 754 编码格式也意味着二进制值可能会表示一个完全不同的
数值。为了鉴别整数是否在这个范围内，可以使用 Number.isSafeInteger()方法： */
        // console.log(Number.isSafeInteger(-1 * (2** 53)));
        // console.log(Number.isSafeInteger(-1 * (2 ** 53) + 1));
        // console.log(Number.isSafeInteger(2 ** 53));
        // console.log(Number.isSafeInteger((2 ** 53) - 1));

        // String
        let stringObject = new String("你好 世界")
        let stringValue = "hello world"

        /* 注意，即使字符串中包含双字节
字符（而不是单字节的 ASCII 字符），也仍然会按单字符来计数。 */
        console.log(stringValue.length);
        console.log(stringObject.length);

        let message = "法师赵海柱"
        let message2 = "1abcd"
        // charAt()方法返回给定索引位置的字符，由传给方法的整数参数指定。
        console.log(message.charAt(0));

        // 使用 charCodeAt()方法可以查看指定码元的字符编码。
        console.log(message.charCodeAt(0));
        console.log(message2.charCodeAt(0));
    </script>
</body>
</html>