<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>原始值包装类型</title>
</head>
<body>
    <script>
        /* 为了方便操作原始值， ECMAScript 提供了 3 种特殊的引用类型： Boolean、 Number 和 String。
这些类型具有本章介绍的其他引用类型一样的特点，但也具有与各自原始类型对应的特殊行为。每当用
到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的
各种方法。 */
        // let s1 = "some text";
        // let s2 = s1.substring(2);
        // console.log(s2);

        /* 当
第二行访问 s1 时，是以读模式访问的，也就是要从内存中读取变量保存的值。在以读模式访问字符串
值的任何时候，后台都会执行以下 3 步：
        (1) 创建一个 String 类型的实例；
        (2) 调用实例上的特定方法；
        (3) 销毁实例。
        */
    //    let s1 = new String("some text");
    //    let s2 = s1.substring(2);
    //    s1 = null;

        /* 引用类型与原始值包装类型的主要区别在于对象的生命周期。在通过 new 实例化引用类型后，得到
的实例会在离开作用域时被销毁，而自动创建的原始值包装对象则只存在于访问它的那行代码执行期
间。这意味着不能在运行时给原始值添加属性和方法。 */

        // let s1 = "some text";
        // s1.color = "red";
        // console.log(s1.color); // undefined

        // let obj = new Object("some text");
        // console.log(obj instanceof String);

//         如果传给 Object 的是字符串，则会创建一个 String 的实例。如果是数值，则会创建 Number 的
// 实例。布尔值则会得到 Boolean 的实例。

        // 注意，使用 new 调用原始值包装类型的构造函数，与调用同名的转型函数并不一样。例如：

        // let value = "25"
        // let number = Number(value) // 转型函数
        // console.log(typeof number);

        // let obj = new Number(value) // 构造函数
        // console.log(typeof obj);

        // Boolean
        /* Boolean 是对应布尔值的引用类型。要创建一个 Boolean 对象，就使用 Boolean 构造函数并传入
true 或 false，如下例所示： */
        let booleanObject = new Boolean(true);
        /* Boolean 的实例会重写 valueOf()方法，返回一个原始值 true 或 false。 toString()方法被调
用时也会被覆盖，返回字符串"true"或"false"。 */
        let falseObject = new Boolean(false);
        let result = falseObject && true;
        // console.log(result);

        let falseValue = false;
        result = falseValue && true;
        // console.log(result);
        /* 除此之外，原始值和引用值（ Boolean 对象）还有几个区别。首先， typeof 操作符对原始值返回
"boolean"，但对引用值返回"object"。同样， Boolean 对象是 Boolean 类型的实例，在使用
instaceof 操作符时返回 true，但对原始值则返回 false，如下所示： */
        // console.log(typeof falseObject);
        // console.log(typeof falseValue);
        // console.log(falseObject instanceof Boolean);
        // console.log(falseValue instanceof Boolean);

        // Number
        /* Number 是对应数值的引用类型。要创建一个 Number 对象，就使用 Number 构造函数并传入一个
数值，如下例所示： */
        let numberObject = new Number(10)
        /* 与 Boolean 类型一样， Number 类型重写了 valueOf()、 toLocaleString()和 toString()方
法。 valueOf()方法返回 Number 对象表示的原始数值，另外两个方法返回数值字符串。 */
        // console.log(numberObject.valueOf());
        // console.log(numberObject.toLocaleString());
        // toString() 方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串，如下所示：
        // let num = 10
        // console.log(num.toString());
        // console.log(num.toString(2));
        // console.log(num.toString(8));
        // console.log(num.toString(10));
        // console.log(num.toString(16));

        /* 除了继承的方法， Number 类型还提供了几个用于将数值格式化为字符串的方法。
toFixed()方法返回包含指定小数点位数的数值字符串，如： */

        let num = 10
        // console.log(num.toFixed(2));
        // 如果数值本身的小数位超过了参数指定的位数，则四舍五入到最接近的116 第 5 章 基本引用类型小数位
        let num2 = 10.005
        // console.log(num2.toFixed(2));
        /* 注意 toFixed()方法可以表示有 0~20 个小数位的数值。某些浏览器可能支持更大的范
围，但这是通常被支持的范围。 */

        let num3 = 10;
        // console.log(num3.toExponential(1));
        // 一般来说，这么小的数不用表示为科学记数法形式。如果想得到数值最适当的形式，那么可以使用 toPrecision()。
        // console.log(num3.toPrecision());
        // 这个方法接收一个参数，表示结果中数字的总位数（不包含指数）。
        let num4 = 99;
        // console.log(num4.toPrecision(1));
        // console.log(num4.toPrecision(2));
        // console.log(num4.toPrecision(3));
        /* 注意 toPrecision()方法可以表示带 1~21 个小数位的数值。某些浏览器可能支持更大
的范围，但这是通常被支持的范围。 */
        let numberValue = 10
        // console.log(typeof numberObject);
        // console.log(typeof numberValue);
        // console.log(numberObject instanceof Number);
        // console.log(numberValue instanceof Number);

        // isInteger()方法和安全整数
        /* ES6 新增了 Number.isInteger()方法，用于辨别一个数值是否保存为整数。有时候，小数位的 0
可能会让人误以为数值是一个浮点值： */
        // console.log(Number.isInteger(1));
        // console.log(Number.isInteger(1.00));
        // console.log(Number.isInteger(1.01));
        /* IEEE 754 数值格式有一个特殊的数值范围，在这个范围内二进制值可以表示一个整数值。这个数值
范围从 Number.MIN_SAFE_INTEGER（ -2^53 + 1）到 Number.MAX_SAFE_INTEGER（ 2^53 - 1）。对超出这
个范围的数值，即使尝试保存为整数， IEEE 754 编码格式也意味着二进制值可能会表示一个完全不同的
数值。为了鉴别整数是否在这个范围内，可以使用 Number.isSafeInteger()方法： */
        // console.log(Number.isSafeInteger(-1 * (2** 53)));
        // console.log(Number.isSafeInteger(-1 * (2 ** 53) + 1));
        // console.log(Number.isSafeInteger(2 ** 53));
        // console.log(Number.isSafeInteger((2 ** 53) - 1));

        // String
        let stringObject = new String("你好 世界")
        let stringValue = "hello world"

        /* 注意，即使字符串中包含双字节
字符（而不是单字节的 ASCII 字符），也仍然会按单字符来计数。 */
        // console.log(stringValue.length);
        // console.log(stringObject.length);

        let message = "法师赵海柱"
        let message2 = "abcde"
        // charAt()方法返回给定索引位置的字符，由传给方法的整数参数指定。
        // console.log(message.charAt(0));

        // 使用 charCodeAt()方法可以查看指定码元的字符编码。
        // console.log(message.charCodeAt(0));
        // console.log(message2.charCodeAt(2));

        // 十进制 99 等于十六进制 63
        // console.log(99 === 0x63);

        // fromCharCode()方法用于根据给定的 UTF-16 码元创建字符串中的字符。这个方法可以接受任意多个数值，并返回将所有数值对应的字符拼接起来的字符串
        // console.log(String.fromCharCode(0x61,0x62,0x63,0x64,0x65));

        // console.log(String.fromCharCode(97,98,99,100,101));

        let message3 = "ab😊de"

        // console.log(0x1F60A);

        // console.log(message3.length);
        // console.log(message3.charAt(1));
        // console.log(message3.charAt(2));
        // console.log(message3.charAt(3));
        // console.log(message3.charAt(4));

        // console.log(message3.charCodeAt(1));
        // console.log(message3.charCodeAt(2));
        // console.log(message3.charCodeAt(3));
        // console.log(message3.charCodeAt(4));

        // 为正确解析既包含单码元字符又包含代理对字符的字符串，可以使用 codePointAt()来代替charCodeAt()。
        // 跟使用 charCodeAt()时类似， codePointAt()接收 16 位码元的索引并返回该索引位置上的码点。码点是 Unicode 中一个字符的完整标识。
        // console.log(String.fromCodePoint(0x1F60A));
        // console.log(String.fromCharCode(97,98,55357,56842,100,101));
        // 码点可能是 16 位，也可能是 32 位，而 codePointAt()方法可以从指定码元位置识别完整的码点。

        // console.log(message3.codePointAt(1));
        // console.log(message3.codePointAt(2));
        // console.log(message3.codePointAt(3));
        // console.log(message3.codePointAt(4));
        // 注意，如果传入的码元索引并非代理对的开头，就会返回错误的码点。这种错误只有检测单个字符的时候才会出现，可以通过从左到右按正确的码元数遍历字符串来规避。
        // console.log([..."ab😊d"]);

        // 与 charCodeAt()有对应的 codePointAt()一样， fromCharCode()也有一个对应的 fromCodePoint()。这个方法接收任意数量的码点，返回对应字符拼接起来的字符串
        // console.log(String.fromCharCode(97,98,55357,56842,100,101));
        // console.log(String.fromCodePoint(97,98,128522,100,101));


        // normalize()方法
        // 上面带圆圈的大写拉丁字母 A
        // console.log(String.fromCharCode(0x00c5));
        // 长度单位“埃”
        // console.log(String.fromCharCode(0x212B));
        // 大写拉丁字母 A
        // 上面加个圆圈
        // console.log(String.fromCharCode(0x0041,0x030A));
        // 比较操作符不在乎字符看起来是什么样的，因此这 3 个字符互不相等。
        let a1 = String.fromCharCode(0x00C5),
        a2 = String.fromCharCode(0x212B),
        a3 = String.fromCharCode(0x0041,0x030A)

        // console.log(a1,a2,a3);
        // console.log(a1 === a2);
        // console.log(a1 === a3);
        // console.log(a2 === a3);

        // 为解决这个问题， Unicode 提供了 4 种规范化形式，可以将类似上面的字符规范化为一致的格式，无论底层字符的代码是什么。
        // 这 4 种规范化形式是： NFD（ Normalization Form D）、 NFC（ Normalization Form C）、NFKD（ Normalization Form KD）和 NFKC（ Normalization Form KC）。

        // console.log(a1 === a1.normalize("NFD"));
        // console.log(a1 === a1.normalize("NFC"));
        // console.log(a1 === a1.normalize("NFKD"));
        // console.log(a1 === a1.normalize("NFKC"));

        // 选择同一种规范化形式可以让比较操作符返回正确的结果
        // console.log(a1.normalize("NFD") ===  a2.normalize("NFD"));
        // console.log(a2.normalize("NFKC") === a3.normalize("NFKC"));
        // console.log(a1.normalize("NFC") === a3.normalize("NFC"));

        /* 字符串操作方法 */
        // 首先是 concat()，用于将一个或多个字符串拼接成一个新字符串。
        let StringValue = "hello ";
        let result2 = StringValue.concat("world")
        // console.log(result2);
        // console.log(StringValue);

        // concat()方法可以接收任意多个参数，因此可以一次性拼接多个字符串
        let result3 = StringValue.concat("world","!")
        // console.log(result3);

        // ECMAScript 提供了 3 个从字符串中提取子字符串的方法： slice()、 substr()和 substring()。
        // 这3 个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。
        // 第一个参数表示子字符串开始的位置，第二个参数表示子字符串结束的位置。对 slice()和 substring()而言，第二个参数是提取结束的位置（即该位置之前的字符会被提取出来）。
        // 对 substr()而言，第二个参数表示返回的子字符串数量。

        let StringValue3 = "hello world"
        console.log(StringValue3);

        // console.log(StringValue3.slice(3));
        // console.log(StringValue3.substring(3));
        // console.log(StringValue3.substr(3));

        console.log(StringValue3.slice(3,7));
        console.log(StringValue3.substring(3,7));
        console.log(StringValue3.substr(3,7));

        
    </script>
</body>
</html>